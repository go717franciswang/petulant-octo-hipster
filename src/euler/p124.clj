(ns euler.p124
  (:require euler.helper))

(def cap 1E5)

(def idx 1E4)

(def primes (euler.helper/primes (* 0.2 cap)))

; would have been much more efficient if the first 2k rads
; were generated by factorization instead of combinatorics of primes
(def sorted-radic-factors
  (loop [primes primes
         results []]
    (if (empty? primes)
      (map second results)
      (let [p (first primes)
            more-results (for [[product nums] results
                               :let [new-product (* product p)
                                     new-nums (conj nums p)]
                               :while (<= new-product cap)]
                           [new-product new-nums])
            results (doall (sort-by first (concat [[p [p]]] results more-results)))]
        (recur (rest primes) results)))))

(defn nums [factors]
  (loop [factors factors
         nums []]
    (if (empty? factors)
      nums
      (recur
        (rest factors)
        (if (empty? nums)
          (for [x (rest (range))
                :let [n (int (Math/pow (first factors) x))]
                :while (<= n cap)]
            n)
          (for [n nums
                x (rest (range))
                :let [new-n (* n (int (Math/pow (first factors) x)))]
                :while (<= new-n cap)]
            new-n))))))

(loop [factors sorted-radic-factors
       nums-count 1]
  (let [nums-with-same-radic (nums (first factors))
        new-nums-count (+ nums-count (count nums-with-same-radic))]
    (if (< new-nums-count idx)
      (recur (rest factors) new-nums-count)
      (first (drop (- idx nums-count 1) (vec (sort nums-with-same-radic)))))))
